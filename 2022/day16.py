"""
2022 Day 16
https://adventofcode.com/2022/day/16
"""

from collections import deque
from dataclasses import dataclass
from functools import cached_property, reduce
from itertools import combinations
from operator import and_ as intersection
import re
import aocd  # type: ignore

re_valve = re.compile(
    r"Valve (\w+) has flow rate=(\d+); tunnels? leads? to valves? ([\w, ]+)"
)


@dataclass(frozen=True)
class Valve:
    """
    One of the pressure valves in the maze.
    """

    name: str
    flow_rate: int
    tunnels: frozenset[str]

    @classmethod
    def from_text(cls, text: str) -> "Valve":
        """
        Read a Valve from its description in a single line of the puzzle input.
        """
        if not (match := re_valve.match(text)):
            raise ValueError(f"Could not find Valve description in line {repr(text)}")

        return cls(
            match.groups()[0],
            int(match.groups()[1]),
            frozenset(match.groups()[2].split(", ")),
        )


@dataclass(frozen=True)
class State:
    """
    A possible state whilst exploring a system of valves.
    """

    time: int
    location: str
    open_valves: frozenset[str]
    pressure: int


@dataclass
class ValveSystem:
    """
    A system of valves and operations for traversing them to solve this day's puzzle.
    """

    valves: dict[str, Valve]

    @classmethod
    def from_text(cls, text: str) -> "ValveSystem":
        """
        Read the system from the puzzle input.
        """
        return cls(
            {
                valve.name: valve
                for valve in (Valve.from_text(line) for line in text.splitlines())
            }
        )

    @cached_property
    def graph(self) -> dict[str, dict[str, int]]:
        """
        Return the graph of the shortest distances between each set of locations in the system.
        This in the format of a dictionary of dictionaries, such that an individual shortest
        distance can be looked up via valve_system.graph[origin][destination].
        """
        graph: dict[str, dict[str, int]] = {}

        for start in self.valves.keys():
            distances: dict[str, int] = {}
            consider = deque([(start, 0)])

            while consider:
                location, steps = consider.popleft()
                if location != start:
                    distances[location] = steps
                for adjacent in self.valves[location].tunnels:
                    if (adjacent != start) and (adjacent not in distances):
                        consider.append((adjacent, steps + 1))

            graph[start] = distances

        return graph

    def best_pressure_possibilities(self, time: int) -> dict[frozenset[str], int]:
        """
        Explore possible moves within the system and return a mapping of possible sets of turned-on
        valves to the maximum pressure that can be generated by that set.
        """
        results: dict[frozenset[str], int] = {}
        worthy_valves = set(
            valve.name for valve in self.valves.values() if valve.flow_rate > 0
        )

        consider = deque([State(time, "AA", frozenset(), 0)])
        while consider:
            state = consider.popleft()

            current_best = results.get(state.open_valves, -1)
            if state.pressure > current_best:
                results[state.open_valves] = state.pressure

            for neighbour, distance in self.graph[state.location].items():
                if (neighbour not in state.open_valves) and (
                    neighbour in worthy_valves
                ):
                    new_time = state.time - distance - 1
                    if new_time >= 0:
                        extra_pressure = self.valves[neighbour].flow_rate * new_time
                        consider.append(
                            State(
                                new_time,
                                neighbour,
                                state.open_valves | {neighbour},
                                state.pressure + extra_pressure,
                            )
                        )

        return results

    def most_pressure_possible(self, time: int, actors: int) -> int:
        """
        Return the maximum amount of pressure that can be generated in this valve system in the
        given amount of time by the given number of actors.
        """
        possible = self.best_pressure_possibilities(time)
        if actors == 1:
            return max(possible.values())
        return max(
            sum(possible[valve_set] for valve_set in combo)
            for combo in combinations(possible, actors)
            if len(reduce(intersection, combo)) == 0
        )


def test_part1() -> None:
    """
    Examples for Part 1.
    """
    assert Valve.from_text(
        "Valve AA has flow rate=0; tunnels lead to valves DD, II, BB"
    ) == Valve("AA", 0, frozenset(("DD", "II", "BB")))
    assert Valve.from_text(
        "Valve DD has flow rate=20; tunnels lead to valves CC, AA, EE"
    ) == Valve("DD", 20, frozenset(("CC", "AA", "EE")))
    assert Valve.from_text(
        "Valve HH has flow rate=22; tunnel leads to valve GG"
    ) == Valve("HH", 22, frozenset(("GG",)))
    valves = {
        "AA": Valve("AA", 0, frozenset(("DD", "II", "BB"))),
        "BB": Valve("BB", 13, frozenset(("CC", "AA"))),
        "CC": Valve("CC", 2, frozenset(("DD", "BB"))),
        "DD": Valve("DD", 20, frozenset(("CC", "AA", "EE"))),
        "EE": Valve("EE", 3, frozenset(("FF", "DD"))),
        "FF": Valve("FF", 0, frozenset(("EE", "GG"))),
        "GG": Valve("GG", 0, frozenset(("FF", "HH"))),
        "HH": Valve("HH", 22, frozenset(("GG",))),
        "II": Valve("II", 0, frozenset(("AA", "JJ"))),
        "JJ": Valve("JJ", 21, frozenset(("II",))),
    }

    system = ValveSystem.from_text(
        "\n".join(
            (
                "Valve AA has flow rate=0; tunnels lead to valves DD, II, BB",
                "Valve BB has flow rate=13; tunnels lead to valves CC, AA",
                "Valve CC has flow rate=2; tunnels lead to valves DD, BB",
                "Valve DD has flow rate=20; tunnels lead to valves CC, AA, EE",
                "Valve EE has flow rate=3; tunnels lead to valves FF, DD",
                "Valve FF has flow rate=0; tunnels lead to valves EE, GG",
                "Valve GG has flow rate=0; tunnels lead to valves FF, HH",
                "Valve HH has flow rate=22; tunnel leads to valve GG",
                "Valve II has flow rate=0; tunnels lead to valves AA, JJ",
                "Valve JJ has flow rate=21; tunnel leads to valve II",
            )
        )
    )

    assert system.valves == valves
    assert len(system.graph) == 10
    assert sum(len(node) for node in system.graph.values()) == 90
    assert system.graph["AA"]["BB"] == 1
    assert system.graph["AA"]["EE"] == 2
    assert system.graph["FF"]["AA"] == 3
    assert system.graph["JJ"]["BB"] == 3

    possible = system.best_pressure_possibilities(30)
    assert frozenset(("BB",)) in possible
    assert frozenset(("AA", "GG")) not in possible
    assert frozenset(("BB", "HH")) in possible
    assert possible[frozenset(("BB", "CC", "DD", "EE", "HH", "JJ"))] == 1651

    assert system.most_pressure_possible(30, 1) == 1651


def test_part2() -> None:
    """
    Examples for Part 2.
    """
    valves = {
        "AA": Valve("AA", 0, frozenset(("DD", "II", "BB"))),
        "BB": Valve("BB", 13, frozenset(("CC", "AA"))),
        "CC": Valve("CC", 2, frozenset(("DD", "BB"))),
        "DD": Valve("DD", 20, frozenset(("CC", "AA", "EE"))),
        "EE": Valve("EE", 3, frozenset(("FF", "DD"))),
        "FF": Valve("FF", 0, frozenset(("EE", "GG"))),
        "GG": Valve("GG", 0, frozenset(("FF", "HH"))),
        "HH": Valve("HH", 22, frozenset(("GG",))),
        "II": Valve("II", 0, frozenset(("AA", "JJ"))),
        "JJ": Valve("JJ", 21, frozenset(("II",))),
    }
    system = ValveSystem(valves)
    possible = system.best_pressure_possibilities(26)
    assert possible[frozenset(("DD", "HH", "EE"))] == 943
    assert possible[frozenset(("JJ", "BB", "CC"))] == 764
    assert system.most_pressure_possible(26, 2) == 1707


def main() -> None:
    """
    Calculate and output the solutions based on the real puzzle input.
    """
    data = aocd.get_data(year=2022, day=16)
    system = ValveSystem.from_text(data)

    print(f"Part 1: {system.most_pressure_possible(30, 1)}")
    print(f"Part 2: {system.most_pressure_possible(26, 2)}")


if __name__ == "__main__":
    main()
